import ast.AST.*;

import java.lang.annotation.Target;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;

import ByteUtils.Bytecode;
import ByteUtils.BytecodeType;


interface BytecodeGenerator extends Iterator<Bytecode> {}


class Compiler {
    private final TreeNode tree;

    /**
     * Constructs a Compiler instance with a given syntax tree.
     * 
     * @param tree2 The root of the syntax tree to be compiled.
     */
    public Compiler(Object tree2) {
        this.tree = (TreeNode) tree2;
    }

    /**
     * Compiles the syntax tree into a sequence of bytecodes.
     * 
     * @return A BytecodeGenerator capable of iterating over the generated bytecodes.
     */
    public BytecodeGenerator compile() {
        return new BytecodeGeneratorImpl(this._compile(tree));
    }

    /**
     * Recursively compiles a TreeNode into an iterable collection of Bytecodes.
     * This method dynamically invokes the appropriate compile method for the type of TreeNode.
     * 
     * @param tree The TreeNode to compile.
     * @return An Iterable collection of Bytecode objects generated from the TreeNode.
     */
    private Iterable<Bytecode> _compile(TreeNode tree) {
        String nodeName = tree.getClass().getSimpleName();
        try {
            String capitalizedNodeName = Character.toUpperCase(nodeName.charAt(0)) + nodeName.substring(1);
            // Dynamically invokes the compile method for the specific type of TreeNode
            return (Iterable<Bytecode>) this.getClass().getDeclaredMethod("compile" + capitalizedNodeName, tree.getClass()).invoke(this, tree);
        } catch (Exception e) {
            String capitalizedNodeName = Character.toUpperCase(nodeName.charAt(0)) + nodeName.substring(1);
            System.out.println("compile" + capitalizedNodeName);
            throw new RuntimeException("Can't compile " + nodeName, e);
        }
    }

    /**
     * Compiles a Program node into a list of Bytecodes.
     * 
     * @param program The Program node to compile.
     * @return A list of Bytecodes representing the compiled program.
     */
    private Iterable<Bytecode> compileProgram(Program program) {
        List<Bytecode> bytecodes = new ArrayList<>();
        for (TreeNode statement : program.getStatements()) {
            // Compiles each statement in the program into Bytecodes and adds them to the list
            for (Bytecode bc : _compile(statement)) {
                bytecodes.add(bc);
            }
        }
        return bytecodes;
    }

    /**
     * Compiles a Conditional node into a list of Bytecodes.
     * This method handles the compilation of conditional statements, including if-else structures.
     * 
     * @param conditional The Conditional node to compile.
     * @return A list of Bytecodes representing the compiled conditional statement.
     */
    private Iterable<Bytecode> compileConditional(Conditional conditional) {
        List<Bytecode> bytecodes = new ArrayList<>();
        // Compile the condition part of the conditional statement
        for (Bytecode bc : _compile(conditional.getCondition())) {
            bytecodes.add(bc);
        }
        // Compile the body of the conditional statement
        List<Bytecode> bodyBytecode = new ArrayList<>();
        for (Bytecode bc : _compile(conditional.getBody())) {
            bodyBytecode.add(bc);
        }
        // Add a jump instruction based on the condition evaluation
        bytecodes.add(new Bytecode(BytecodeType.POP_JUMP_IF_FALSE, bodyBytecode.size() + 1));
        bytecodes.addAll(bodyBytecode);
        return bytecodes;
    }

    /**
     * Compiles a Body node into a list of Bytecodes.
     * This method handles the compilation of a block of statements, typically found within loops or conditionals.
     * 
     * @param body The Body node to compile.
     * @return A list of Bytecodes representing the compiled block of statements.
     */
    private Iterable<Bytecode> compileBody(Body body) {
        List<Bytecode> bytecodes = new ArrayList<>();
        // Compile each statement in the body
        for (TreeNode statement : body.getStatements()) {
            for (Bytecode bc : _compile(statement)) {
                bytecodes.add(bc);
            }
        }
        return bytecodes;
    }

    /**
     * Compiles an Assignment node into a list of Bytecodes.
     * This method handles the compilation of assignment statements, including those with multiple targets.
     * 
     * @param assignment The Assignment node to compile.
     * @return A list of Bytecodes representing the compiled assignment statement.
     */
    private Iterable<Bytecode> compileAssignemnt(Assignment assignment) {
        List<Bytecode> bytecodes = new ArrayList<>();
        // Compile the value to be assigned
        for (Bytecode bc : _compile(assignment.getValue())) {
            bytecodes.add(bc);
        }
        // Handle multiple assignment targets
        for (int i = 0; i < assignment.getTargets().size() - 1; i++) {
            bytecodes.add(new Bytecode(BytecodeType.COPY));
            bytecodes.add(new Bytecode(BytecodeType.SAVE, assignment.getTargets().get(i).getName()));
        }
        bytecodes.add(new Bytecode(BytecodeType.SAVE, assignment.getTargets().get(assignment.getTargets().size() - 1).getName()));
        return bytecodes;
    }

    /**
     * Compiles an expression statement into a list of Bytecodes.
     * This method handles the compilation of expression statements, which are expressions that are executed for their side effects.
     * 
     * @param expression The ExprStatement node to compile.
     * @return A list of Bytecodes representing the compiled expression statement.
     */
    private Iterable<Bytecode> compileExprStatement(ExprStatement expression) {
        List<Bytecode> bytecodes = new ArrayList<>();
        for (Bytecode bc : _compile(expression.getExpr())) {
            bytecodes.add(bc);
        }
        bytecodes.add(new Bytecode(BytecodeType.POP));
        return bytecodes;
    }

    /**
     * Compiles a unary operation into a list of Bytecodes.
     * This method handles the compilation of unary operations, such as negation or logical not.
     * 
     * @param tree The UnaryOp node to compile.
     * @return A list of Bytecodes representing the compiled unary operation.
     */
    private Iterable<Bytecode> compileUnaryOp(UnaryOp tree) {
        List<Bytecode> bytecodes = new ArrayList<>();
        for (Bytecode bc : _compile(tree.getValue())) {
            bytecodes.add(bc);
        }
        bytecodes.add(new Bytecode(BytecodeType.UNARYOP, tree.getOp()));
        return bytecodes;
    }

    /**
     * Compiles a binary operation into a list of Bytecodes.
     * This method handles the compilation of binary operations, such as addition, subtraction, or comparison.
     * 
     * @param tree The BinaryOp node to compile.
     * @return A list of Bytecodes representing the compiled binary operation.
     */
    private Iterable<Bytecode> compileBinaryOp(BinaryOp tree) {
        List<Bytecode> bytecodes = new ArrayList<>();
        for (Bytecode bc : _compile(tree.getLeft())) {
            bytecodes.add(bc);
        }
        for (Bytecode bc : _compile(tree.getRight())) {
            bytecodes.add(bc);
        }
        bytecodes.add(new Bytecode(BytecodeType.BINARYOP, tree.getOp()));
        return bytecodes;
    }

    /**
     * Compiles a constant value into a Bytecode.
     * This method handles the compilation of constants, embedding them directly into the bytecode stream.
     * 
     * @param constant The Constant node to compile.
     * @return A list of Bytecodes representing the compiled constant.
     */
    private Iterable<Bytecode> compileConstant(Constant constant) {
        List<Bytecode> bytecodes = new ArrayList<>();
        bytecodes.add(new Bytecode(BytecodeType.PUSH, constant.getValue()));
        return bytecodes;
    }

    /**
     * Compiles a Variable node into a list of Bytecodes.
     * This method handles the compilation of variable access, generating bytecode to load the variable's value.
     * 
     * @param var The Variable node representing the variable to be loaded.
     * @return A list of Bytecodes representing the compiled variable access.
     */
    private Iterable<Bytecode> compileVariable(Variable var) {
        List<Bytecode> bytecodes = new ArrayList<>();
        bytecodes.add(new Bytecode(BytecodeType.LOAD, var.getName()));
        return bytecodes;
    }

    /**
     * An implementation of the BytecodeGenerator interface.
     * This class provides an iterator over a collection of Bytecodes, allowing them to be sequentially accessed.
     */
    private class BytecodeGeneratorImpl implements BytecodeGenerator {
        private final Iterator<Bytecode> iterator; // Iterator over the Bytecodes

        /**
         * Constructs a BytecodeGeneratorImpl with a given collection of Bytecodes.
         * 
         * @param bytecodes The collection of Bytecodes to iterate over.
         */
        public BytecodeGeneratorImpl(Iterable<Bytecode> bytecodes) {
            this.iterator = bytecodes.iterator();
        }

        /**
         * Checks if there are more Bytecodes to be generated.
         * 
         * @return true if there are more Bytecodes, false otherwise.
         */
        @Override
        public boolean hasNext() {
            return iterator.hasNext();
        }

        /**
         * Returns the next Bytecode in the sequence.
         * 
         * @return The next Bytecode.
         * @throws RuntimeException if there are no more Bytecodes to generate.
         */
        @Override
        public Bytecode next() {
            if (!hasNext()) {
                throw new RuntimeException("No more bytecode");
            }
            return iterator.next();
        }

        /**
         * Performs the given action for each remaining Bytecode until all have been processed or the action throws an exception.
         * 
         * @param action The action to be performed for each Bytecode.
         */
        @Override
        public void forEachRemaining(Consumer<? super Bytecode> action) {
            iterator.forEachRemaining(action);
        }
    }

    
}
